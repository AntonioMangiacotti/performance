#!/usr/bin/perl

# perfanalyze_dynamicsql.pl
# Author: Casey Peel (cpeel@us.ibm.com)
#         Dave Bachmann (bachmann@us.ibm.com)
# Last Updated: 2009/05/27 0734 MDT
# Summary:
#    Analyzes dynamic sql snapshots for problem queries
# Description:
#    This script analyses a dyanmic sql snapshot from DB2 and gives an
#    analysis for long-running queries.
#
#    This script makes use of the data from uow, timestamp, and statement
#    monitoring from DB2. These three monitoring flags must be enabled
#    prior to the snapshot for this report to generate useful results.
#
#    You can get a dynamic sql snapshot by running:
#       db2 connect to DBNAME
#       db2 get snapshot for dynamic sql on DBNAME
#    or
#       db2 connect to DBNAME
#       db2 get snapshot for all on DBNAME
#    as the ITDS database owner.
#

use Getopt::Std;
use strict;

# Debug?
our $DEBUG=0;

our %options;

getopts('i:d:o:t:c:r:hasnwx', \%options) or usage();
usage() if($options{h});

# Print Usage and exit
sub usage {
   print STDERR <<EOF

Usage: $0 [ -i inputFile | [ -d databaseName | -s ] ] [ -o outputFile ] [ -c cutOff | -t truncLine ] [ -w | -n | -a ]
Output options:
  -a - show all statements, even those generated by explain plans, etc
  -t - length to truncate statement at, default is 80 characters. 0 = don't truncate.
  -c - time cutoff; statements longer than this time are not included, default is 0.1
  -r - column to sort by, default is secPerExec
  -n - include queries that have no statistics information
  -w - include the number of rows written
  -x - display total execution time

Other options:
  -i - file containing dynamic sql statements for processing
  -d - database name to get dynamic sql statements from directly
  -s - if given the temporary file with the dynamic sql will be saved
  -o - file to put the processed results in, default is STDOUT


If no arguments are given, the program will read input from STDIN.

EOF
;
exit;
}

# Only specify either -i or -d
if($options{i} && $options{d}) {
   print STDERR "Only one of the -i or the -d parameters should be used at a time.\n";
   print STDERR "If you have a snapshot already, use -i.\n";
   print STDERR "If you want to have the script pull the snapshot, use -d.\n";
   exit 1;
}

# Open an existing file if one is given
our $inputFileHandle;
if($options{i}) {
   if(-f $options{i}) {
      open INPUT, $options{i} || die("Unable to open file $options{i}\n");
      $inputFileHandle=*INPUT;
   } else {
      die("Unable to open file $options{i}\n");
   }
}

# Fetch the data from the database ourselves
our $tempFilename;
if($options{d} ne "") {
   print "getting snapshot from database $options{d}\n";
   my $date=strftime("%Y%m%d-%H%M",localtime);
   $tempFilename="snapshot-dynamicsql.$date";
   system("db2 get snapshot for dynamic sql on $options{d} > $tempFilename");
   open INPUT, $tempFilename || die("Unable to get dynamic sql from database, check directory permissions\n");
   $inputFileHandle=*INPUT;
}

# Default input is STDIN
if(!$inputFileHandle) {
   print STDERR "no input file specified (-i), reading input from STDIN\n";
   print STDERR "Hint: use the -h option to get the usage statement\n";
   $inputFileHandle=*STDIN;
}

# Default output file is STDOUT
our $outputFileHandle=*STDOUT;

# Unbuffer $outputFileHandle
select((select($outputFileHandle), $|=1)[0]);

# Open the file to put the output in, if necessary
if($options{o}) {
   open OUTPUT, ">$options{o}" || die("Unable to open $options{o} for writing\n");
   $outputFileHandle=*OUTPUT;
}

# set defaults
our $timeCutoff=0.1;
our $statementTruncateLength=80;
our $sortColumn='secPerExec';
our $includeNAStats=0;
our $includeRowsWritten=0;
our $showAllStatements=0;
our $showTotalExecutionTime=0;

# get the command-line options if specified
$timeCutoff=$options{c} if($options{c} ne "");
$statementTruncateLength=$options{t} if($options{t} ne "");
$sortColumn=$options{r} if($options{r});
$includeNAStats=$options{n} if($options{n} ne "");
$includeRowsWritten=1 if($options{w} ne "");
$showAllStatements=1 if($options{a} ne "");
$showTotalExecutionTime=1 if($options{x} ne "");

# set the list of statement strings we want to ignore
our @ignoreStatementStrings=("^create index", "^delete index", "explain_", "sysibm", "syscat", "^alter table", "^set current explain mode","call reorgchk_","update systools");

# print status indicator
print STDERR "processing snapshot";

our %queryHash;
our $databaseName;

# Chunk the file out into stanzas delimited by blank lines
my $queryCount=0;
my $stanza="";
while(my $line=<$inputFileHandle>) {
   if($line=~/^[\r]*$/) {
      if($stanza=~/^ Statement text/im) {
         print STDERR "." if(!($queryCount % 100));
         $queryCount++;
         processStanza($stanza);
      }
      $stanza="";
   } elsif($line=~/^ Database name\s+= (.*)$/i) {
      $databaseName=$1;
   } else {
      $stanza.=$line;
   }
}

sub processStanza {
   my($stanza)=@_;
   my($numExecutions, $totalExecutions, $totalExecutionTime, $rowsRead, $rowsWritten, $statement);

   $stanza=~s/\r//g;

   print "DEBUG: stanza start:\n$stanza\nDEBUG: stanza end\n" if($DEBUG);
   
   if($stanza=~/^ Number of executions\s+= (.*)$/im) {
      my $data=$1; $data="N/A" if($data=~/not collected/i);
      $numExecutions=$data;
   }
   if($stanza=~/^ Total execution time.*= (.*)$/im) {
      my $data=$1; $data="N/A" if($data=~/not collected/i);
      $totalExecutionTime=$data;
   }
   if($stanza=~/^ Rows read\s+= (.*)$/im) {
      my $data=$1; $data="N/A" if($data=~/not collected/i);
      $rowsRead=$data;
   }
   if($stanza=~/^ Rows written\s+= (.*)$/im) {
      my $data=$1; $data="N/A" if($data=~/not collected/i);
      $rowsWritten=$data;
   }
   if($stanza=~/ Statement text\s+= (.*)$/si) {
      $statement=$1;
      # change all newlines/carriage returns to space
      $statement=~s#^\s+##mg;
      $statement=~s#\n# #g;
      # a little statement normalization
      $statement=~s#\s+,\s+#, #g;
      $statement=~s#^(.*?)\s+(\s.*')#$1$2#g;
      $statement=~s#('.*\s)\s+(.*?)$#$1$2#g;
   }
   if($statement) {
      $queryHash{$statement}{'statement'}=$statement;
      $queryHash{$statement}{'numExec'}=$numExecutions;
      $queryHash{$statement}{'totalExecTime'}=$totalExecutionTime;
      $queryHash{$statement}{'rowsWritten'}=$rowsWritten;
      $queryHash{$statement}{'rowsRead'}=$rowsRead;

      if($numExecutions>0 && $totalExecutionTime ne "N/A") {
         my $secPerExec;
         if($showTotalExecutionTime) {
            $secPerExec=$totalExecutionTime;
         } else {
            $secPerExec=$totalExecutionTime/$numExecutions;
         }
         my $rowsReadPerExec=$rowsRead/$numExecutions;
         my $rowsWrittenPerExec=$rowsWritten/$numExecutions;

         $queryHash{$statement}{'secPerExec'}=$secPerExec;
         $queryHash{$statement}{'rowsReadPerExec'}=$rowsReadPerExec;
         $queryHash{$statement}{'rowsWrittenPerExec'}=$rowsWrittenPerExec;
      } else {
         $queryHash{$statement}{'secPerExec'}="N/A";
         $queryHash{$statement}{'rowsReadPerExec'}="N/A";
         $queryHash{$statement}{'rowsWrittenPerExec'}="N/A";
      }
   }
}

print STDERR "\n";

# before actually printing anything, see if our file was valid
if($databaseName eq "") {
   die("Input was not a valid DB2 dynamic sql snapshot, no analysis done.\n");
}

# print newline before we start outputting
print $outputFileHandle "\n";

# sort the data
my @sortedList;
if($sortColumn ne "statement") {
   @sortedList = sort { $queryHash{$a}{$sortColumn} <=> $queryHash{$b}{$sortColumn} } keys %queryHash;
} else {
   @sortedList = sort { $queryHash{$a}{$sortColumn} cmp $queryHash{$b}{$sortColumn} } keys %queryHash;
}

# remove any system statements if necessary
if(!$showAllStatements) {
   foreach my $ignoreStatementString (@ignoreStatementStrings) {
      @sortedList = grep(!/$ignoreStatementString/i, @sortedList);
   }
}


print $outputFileHandle "Dynamic SQL analysis for database: $databaseName\n";
print $outputFileHandle "Total number of statements processed: " . (scalar keys %queryHash) . "\n";
print $outputFileHandle "Legend\n";
if($showTotalExecutionTime) {
   print $outputFileHandle "   execTime - total seconds\n";
} else {
   print $outputFileHandle "   secPerExec - seconds per execution\n";
}
print $outputFileHandle "   numExec - number of executions\n";
if($includeRowsWritten) {
   print $outputFileHandle "   rowsR - number of rows read per execution\n";
   print $outputFileHandle "   rowsW - number of rows written per execution\n";
}
print $outputFileHandle "   statement - statement executed\n";
print $outputFileHandle "\n";
if(!$showAllStatements) {
   print $outputFileHandle "Skipping system statements, override this with the -a option\n";
}
print $outputFileHandle "Skipping statements that executed in less than $timeCutoff second...\n";
print $outputFileHandle "Truncating output to $statementTruncateLength characters...\n" if($statementTruncateLength>0);

if($includeRowsWritten) {
   if($showTotalExecutionTime) {
      print $outputFileHandle "execTime     numExec     rowsR     rowsW  statement\n";
   } else {
      print $outputFileHandle "secPerExec   numExec     rowsR     rowsW  statement\n";
   }
} else {
   if($showTotalExecutionTime) {
      print $outputFileHandle "execTime     numExec  statement\n";
   } else {
      print $outputFileHandle "secPerExec   numExec  statement\n";
   }
}

foreach my $statement (@sortedList) {
   my $numExec=$queryHash{$statement}{'numExec'};
   my $secPerExec=$queryHash{$statement}{'secPerExec'};
   my $rowsReadPerExec=$queryHash{$statement}{'rowsReadPerExec'};
   my $rowsWrittenPerExec=$queryHash{$statement}{'rowsWrittenPerExec'};

   next if($queryHash{$statement}{'secPerExec'} eq "N/A" && !$includeNAStats);
   next if($queryHash{$statement}{'secPerExec'}<$timeCutoff && $queryHash{$statement}{'secPerExec'} ne "N/A");

   my $statementTrunc=$statement;
   if($statementTruncateLength>0) {
      $statementTrunc=substr($statement,0,$statementTruncateLength) 
   }

   if($includeRowsWritten) {
      if($secPerExec eq "N/A") {
         printf $outputFileHandle "%10s  %8d  %8s  %8s  %s\n", $secPerExec, $numExec, $rowsReadPerExec, $rowsWrittenPerExec, $statementTrunc;
      } else {
         printf $outputFileHandle "%10.4f  %8d  %8d  %8d  %s\n", $secPerExec, $numExec, $rowsReadPerExec, $rowsWrittenPerExec, $statementTrunc;
      }
   } else {
      if($secPerExec eq "N/A") {
         printf $outputFileHandle "%10s  %8d  %s\n", $secPerExec, $numExec, $statementTrunc;
      } else {
         printf $outputFileHandle "%10.4f  %8d  %s\n", $secPerExec, $numExec, $statementTrunc;
      }
   }
}


# Clean up after ourselves
if($options{d} && !$options{s}) {
   unlink $tempFilename if(-f $tempFilename);
}

# vim: sw=3 ts=3 expandtab
